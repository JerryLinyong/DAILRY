#11.02
  es6的语法对变量的赋值，数据类型的操作增加，让最基本的单位数据类型的操作增加了，把数据分割成一个个基本类型，然后对基本类型数据开始操作，基本数据类型按照
层级分类，聚集成一个个数据集合，如数组，对象，set，map。基本数据类型数字，字符串，布尔，symbol类型的数据。集合放在对象中。对象不仅可以储存数据，还可以
储存方法。方法中有自身的方法，还有继承来的方法使用class来定义对象，extends来继承，还有proxy来拦截原型的方法，reflect用来定义，重写原型的方法。/
还有模块的引用，require是实时的，import是提前的，更加快速，但是其中的数值不能发生变化。还有就是异步操作。promise完成单个异步函数的操作，回调，
而yeild async则是将方法内部的步骤在进行细分。
#11.03
  数据结构，算法的基本认识。传输数据需要事先规定好数据传输的形式，如何传输，于是有了很多的协议方式。
根据不同的协议，还有不同的框架，衍生出了许多不同的代码库，这些git上的开源代码打包了很多有用的接口，通过下载包，引用，通过api进行相应的操作，唯一比较
麻烦的是由于数据框架，技术一直在发展，所以很多包都要相应的更新，人的需求也在不断改变，代码更新程度将影响到这个技术的使用范围。所以了解人变化的需求和
掌握最新的技术成为当务之急。想要了解人的需求还是要多问人，多去考察。而新技术也是要多问人，多在网上找资料。还有就是如何能够真正的掌握技术。掌握技术在于
掌握其原理，只有把技术的底部实现原理掌握了才算真的掌握，而一项技术通常可以解决多个问题，所以学的深浅也看你的需求有多少！
#11.04
  尽量把自己每日所要做的事情变少，然后把每一件事情做好，知识，设备，活动。
#11.05
  不怎么需要的东西就不要出现在生活里，会分心，需要的东西也要注意限制，没有限制就不能各自发挥所长！
#11.06
  对象的方法的继承和修饰词来为对象添加个别的方法，继承extends添加多个方法，constructor添加独一属性用来区别，
#11.07
  最佳实践：掌握相关技术，根据要求把技术进行合理运用，追求代码量少简单易懂，运行快。
#11.08
各个组件可能有所依赖，最好是看文档，依据文档来进行使用。组件需要整理，让整个文档结构更加清晰。
#11.09
  每个电子设备通过不同的协议进行通信。软件硬件，有服务器去处理请求，处理信息。单片机，二极管，芯片等等。wifi透传，tcp/ip，websocket，tcp，mqtt，
http不同的数据连接需要不同的包来处理。对数据的转码也需要包，对转码后的数据也需要包来处理。硬件来提供数据计算，储存，接收，发送，软件来处理数据，
接收。设备处理数据，发送数据，接收数据。硬件知识，数据传输协议，数据处理技术。
#11.11
  物联网包含软件和硬件，硬件随时间经常会有老化，腐蚀，污浊现象，灰可以清，锈难清。软件上的bug一定有，有时会直接导致电脑进入死循环，cpu被无限占用，
要能够实时监控计算机cpu，内存，硬盘数据。一款好的软件，不仅要用户体验，还要优化性能，尽量少占用cpu，内存，即在很差的电脑上也要运行流畅。衡量软件
优劣可以看看体验和cpu，内存在使用时的数据。掌握物联网就要掌握硬件和软件，让软件更小，性能更加，更加持久。物品老化是一个值得注意的问题。
#11.12
  数据以不同的形式展现，储存用二进制，转换成相应的数据要知道数据类型。
#11.13
  tcp以二进制传输，然后根据数据类型读取，一排的二进制数，按字节读取，不足一字节的用0来填充位。
##11.14
  要知道代码的底层发生了什么就要对其中涉及的知识有一定了解，可以靠猜，然后去验证，或者去补充学习，要知道这一切绝对不会很难！
#11.16
  看源码，要先了解整体的结构，在看懂每一句的作用。只有对全面的功能有所了解，才是去了解细节的时机。别人的代码过于庞大复杂，必须在脑海里自行补充其他信息，
在去别人的代码里验证。
#11.17
  看别人的代码，首先是了解其结构，然后才能修改，最后才是优化
#11.18
  声乐和光影的变换是UI的关键！
#11.19
  redux中多个reducer合并，让每个reducer分别处理整个应用的一部分。
#11.20
  数据有不同的展示形式，只要掌握了它的形式就可以控制，转换。问题在数据的形式
#11.21
  要掌握每个原始，了解对象的属性方法，了解dom后这个元素的样式，了解每个逻辑
#11.22
  学习：先通晓其大致结构，实践，最后读专业的介绍性书籍。
#11.23
  通过关键字寻找相应的信息，你可以通过这些方法，接口使用，其中较难的是有一些要求，而它无法实现要去试试找隐藏方法，还有一些要求可以实现，但是现在这个
接口不是完善，只有了解原理才能进行修改。
#11.24
  要在开始一个项目前就大致把握整体结构，书写出来，然后按照顺序开始！
#11.26
  选择大公司的框架，bug比较少，也好操作！
#11.27
  三层数据逻辑关系，1.数据库的增删改查 2.页面间的逻辑联系 3.页面的逻辑处理
#11.28
  数据变化就是信号传递建立关系
#11.29
  npm包把相对复杂的源代码编写的功能聚合在一起，暴露几个简单的qpi供使用者使用。
#11.30
  最佳实践的重点在于是否能够理解每一个步骤，能否理解步骤的意图。所以重点在于理解。
#12.1
  数据结构，组件化，数据处理，逻辑结构。数据的层级决定哪里开始调用方法，调用哪个对象的方法。层级，数据库，dom，逻辑
#12.3
  擅用浏览器可以快速的寻找到答案！浏览器加关键字。
#12.4
  不同的包安装方式会对相同的代码产生影响。
  reactnative run android 会提示在安卓手机上跑时报的一些错误。
  电脑上的模拟器旁的照相机图标是用来开启照相机权限的。
  项目的设计先后顺序：数据类型和结构，dom的数据类型和结构，style的数据类型和结构，逻辑的处理。
  lodash处理深层次的操作。
  确认目标，然后理清思路，建立结构。
  lodash和updeep
  表单的格式是最佳实践！
  做页面最起码要把它完整的功能写出来，然后在去简化结构，复用数据。
  复用数据和dom，style，要把完整的功能做出来！
  一个组件的生命周期，包括开始，错误处理，成功处理。
  static是非实例化的类可以访问的，一旦实例化就不可以访问，但是实例化的对象都是拥有这个值的，在要实例化时，看看类有没有这个属性，有就加添一点东西，即
类在实例化时，会对类中的各种方法进行处理。static是在实例化是调用的。而props则是给使用着可以自行定义的东西。static只有开发者可以进行定义。props
使用者可以使用。
  封装即编译成一个包，对方引用，暴露了一些方法，类的实例化立面所有都东西都可以访问到
  类未实例化时都数据，实例化后都数据。
  类应该要传都参数。官方文档最简单都例子。npmjs里面都是官方说明。类和对象就是为了传递一些数据和方法都。
  全局变量，要么位置很前，要么用global关键字。
  暴露都要么是对象要么是方法。
  在去npm库里按照关键字找到最新都包。
  对于数据库都创建，dom有最佳实践到ui库里找，它提供了很多方法用来显示不同样式和状态都ui，然后是数据都处理，如果是相关一系列的操作，都可以找到。
所以最难的是理解它暴露的对象和api以及知道最新的技术。综上，跟上技术比较难。
  最佳实践的选择需要依赖经验和搜索。完整的结构。
#12.5
  git版本控制。拉取如果产生冲突，先把自己保存的放在一边，然后把自己的储存弹出，然后在有冲突的地方，采用拉取到的代码，然后在提交，就可以保存二者代码的
一致性，所以git协作一开始要先规定各自负责的部分，然后经常拉取和推送，通过交流来解决冲突文件。分配任务，然后交流解决冲突。
  组件export default一个类就可以，不要注入依赖，不然会一直循环嵌套，想取到组件里的内容就比较难。
#12.6
  curring是真正的计算逻辑，ramda 是js逻辑必掌握的。
  用不同方式运行代码可以获取不同的信息！
  通过重新定义输出函数，函数里面包含console命令，用函数来定义，即可以控制哪些要输出，哪些不输出！
  通过定义输出函数来更好的控制debug，修改错误！
  对象的查找和遍历是最好的。
  数据一旦躲起来，处理前端和后端就比较复杂。要考虑懒加载，并发。
  前端后端都要考虑当数据大起来大情况，前端要考虑ui的组件是否功能全面。
#12.7
  git要经常拉，保持提交时仍可以运行。
##12.8
  有很多模板，如果照着实践一遍，然后再做一次事情就简单多了，但是可能会有冲突，所以就要学会解决冲突，看看这一次与上一次的有什么不同，
网上可以找到很多资料，但是都不尽相同，还要探寻出每一个不同点里面的逻辑
  前端要根据组件切分，主要完成组件的逻辑。后端要判断每一个异步操作，并在回调时加上数据放回其状态，相当于可以报错了报对。
  #12.11
  todo高亮可以让你记住dev状态下做的一些事情，要在发布状态下进行相应的更改。所有的style都要统一放在一起好管理。
  所有的前端结构都要模块化，标准的结构便于管理：todo hightlight便于区分开发和发布状态要做的事情。
  代码逻辑的优化取决于是否可以进行数据的重复使用。
  promise函数返回一个reject和resolve来进行回调运用then可以执行接下去的函数。还有一个函数async，通过回调来执行告诉await异步执行完成。
async可以说你promise的升级，让回调函数更加清晰，结构可以更好理解。
  generator用来分段一个函数的执行，当一个回调执行到一个阶段，把函数的next嵌套下去，就可以执行了
  如果要做模块组件，不能有专有名称来做变量和props值
  如果不切分组件，完整逻辑的积累会让代码变得十分复杂，所以每一个组件都要做成组件，然后定义相应都props值。虽然很多ui都有很完整都组件
但是切分组件的主要原因，还是组件要处理的逻辑太多了！
#12.21
  saga的run可以让generator一直跑下去。
#12.13
  saga可以暂停每一个yeild函数
#12.14
  一个完整的组件和逻辑要经过测试，只有测试完成了，确认没有bug了，才可以交付使用。写完组件后要把如何使用的方法写清楚，需要传什么格式的文件，
以什么样的形式输出数据。即完成组件或者逻辑的编写后，要把输入和输出的数据格式和方法写完全，让人可以使用。
#12.15
  小队合作，最好是把各自的代码分配清楚，各自负责各自的，有冲突交流解决。
#12.17
  组件的位置如果没有父组件来做对照，很容易位置变得很奇怪，所以在设置组件的位置时要时刻考虑它的父组件是什么，父组件的宽高，位置。
#12.18
  模拟事件比自己手动触发事件方便多了，而且还可以不按照项目多流出走，直接切入核心部分.
#12.19
  后台与异步操作不同，后台表示程序会一直跑，异步表示你可以手动结束
#12.21
  每行代码都有它都作用，了解它都作用只是最基本的，更上一层是了解数据的流动，只有掌握了数据的流动才能真正掌握代码在整个系统里面发挥的作用。
#12.24
  数据没有全部同步更新会有bug
#12.25
  页面通过class包起来，可以通过ref获得数据，style在ref中有变化，但是还是有用的
#12.26
  页面的每一个显示都是一种组件
#12.27
  数据更新只更新修改都部分，深复制成本很高。定时器尽量放在父组件上，减少定时器。shouldcomponentupdate来判断是否重新渲染，一旦定义就会覆盖程序
原先定义的。代码都扩展性要好
#12.28
  每一行不同的代码都会发挥不同都作用，一般不会重合，一旦重合要去修改。
#12.29
  generator函数有yield就不会全部执行，saga有后台会把yield依次执行，哪里停住也可以
#12.30
  模块的好处，在我要在其他地方运用时，显现出来了，模块化的好处真的太多了，一起做过的直接拿来用，都不用重新在写一个了，而且十分浅显易懂，方便
#1.2
  注意数据的解耦，不然一旦有数据改变就会影响其他界面
#1.3
  减少数据间的关联，采用非关系型数据库，关系型数据库逻辑间的关系使得整个项目的逻辑理解起来更加复杂，不利于优化
#1.4
  业务在一开始时不是十分清楚，是慢慢开始变得清楚，产品要细致地推敲，让每一个细节都符合预期，理想
#1.5
  只有做到代码的复用才可能一个顶多个，而代码的复用需要留心页面的元素和代码的每一个。
#1.7
  如果能搞清楚每个数据的作用就很容易修改代码
  一切的策略都是推论，要有素材
#1.8
  写代码用其他人的npm包如果没有遵守他的规则就服务正确地运行
#1.9
  要对逻辑或则是组件进行监控就要全局定义和通用组件
#1.11
  不好用的软件占用的cpu很多，它们没有进行优化。
#1.12
  选择较小的缩放比，可以让页面的效果变化不这么明显
