#11.02
es6的语法对变量的赋值，数据类型的操作增加，让最基本的单位数据类型的操作增加了，把数据分割成一个个基本类型，然后对基本类型数据开始操作，基本数据类型按照
层级分类，聚集成一个个数据集合，如数组，对象，set，map。基本数据类型数字，字符串，布尔，symbol类型的数据。集合放在对象中。对象不仅可以储存数据，还可以
储存方法。方法中有自身的方法，还有继承来的方法使用class来定义对象，extends来继承，还有proxy来拦截原型的方法，reflect用来定义，重写原型的方法。/
还有模块的引用，require是实时的，import是提前的，更加快速，但是其中的数值不能发生变化。还有就是异步操作。promise完成单个异步函数的操作，回调，
而yeild async则是将方法内部的步骤在进行细分。
dom树的建立，css样式表的建立，数值的引用，绑定和方法的挂载
#11.03
数据结构，算法的基本认识。传输数据需要事先规定好数据传输的形式，如何传输，于是有了很多的协议方式。
根据不同的协议，还有不同的框架，衍生出了许多不同的代码库，这些git上的开源代码打包了很多有用的接口，通过下载包，引用，通过api进行相应的操作，唯一比较
麻烦的是由于数据框架，技术一直在发展，所以很多包都要相应的更新，人的需求也在不断改变，代码更新程度将影响到这个技术的使用范围。所以了解人变化的需求和
掌握最新的技术成为当务之急。想要了解人的需求还是要多问人，多去考察。而新技术也是要多问人，多在网上找资料。还有就是如何能够真正的掌握技术。掌握技术在于
掌握其原理，只有把技术的底部实现原理掌握了才算真的掌握，而一项技术通常可以解决多个问题，所以学的深浅也看你的需求有多少！
#11.04
尽量把自己每日所要做的事情变少，然后把每一件事情做好，知识，设备，活动。
#11.05
不怎么需要的东西就不要出现在生活里，会分心，需要的东西也要注意限制，没有限制就不能各自发挥所长！
#11.06
对象的方法的继承和修饰词来为对象添加个别的方法，继承extends添加多个方法，constructor添加独一属性用来区别，
异步通过记号来告诉函数，此次异步执行完毕，可以执行下一个，resolve和reject
（RYZ）
#11.07
  最佳实践：掌握相关技术，根据要求把技术进行合理运用，追求代码量少简单易懂，运行快。
  设计模式：实现项目所需要的技术，并列出在哪要用上这项技术,如store：redux,react-redux,async-storage,MQTT,redux-saga。这是实现store项目所要的技术
  完成项目需要对相关技术的一定了解，由此来进行技术选型，完成设计模式，然后由对技术的深刻理解来完成最佳实践！
  代码的管理：先把框架搭起来，用最简单的代码把整个项目的的依赖库安装，引入在入口文件里，然后创建相应的文件夹，往里面放入相应的代码。以后对项目的更改都
是在相应的文件里面修改，一般情况下尽量不要增减文件数量，会有许多东西要改，所以一开始的项目结构搭建很重要，要确定
  1.需要哪些页面 login main
  2.用什么框架 vue react
  3.ui库，ant design
  4.信息用什么引入，ajax，axios，mqtt
  5.路由怎么搭建
  6.中心仓库是什么
其中路由和技术的选择是要在一开始就做得详细的!
(最佳实践！参考别人的工程文件，文件的结构‘如何模块化’，应用的技术‘选择相应的部分’)\
！开始的页面搭建，然后技术选择，页面：框架和ui，数据处理比较麻烦：语言转换，运用不同的协议获取不同的数据，把数据储存在不同的地方，引用数据，修改数据，
嵌套数据，异步执行，数据类型，依据不同的操作系统有不同的表现引用不同的技术。
 数据储存，引用会影响系统的优化。主要在数据是否可以复用！import和储存和网络请求
（页面样式，响应不同的操作）
（获取数据，数据储存，数据处理）
#11.08
各个组件可能有所依赖，最好是看文档，依据文档来进行使用。组件需要整理，让整个文档结构更加清晰。
对整个项目的需求要很清楚才能把项目很好的切分。
一开始要先有个整体概念，然后根据需求不断往上面添加依赖库和界面。
项目由'页面'和'数据'组成，'组织'它们使其简单易懂。
#11.09
每个电子设备通过不同的协议进行通信。软件硬件，有服务器去处理请求，处理信息。单片机，二极管，芯片等等。wifi透传，tcp/ip，websocket，tcp，mqtt，
http不同的数据连接需要不同的包来处理。对数据的转码也需要包，对转码后的数据也需要包来处理。硬件来提供数据计算，储存，接收，发送，软件来处理数据，
接收。设备处理数据，发送数据，接收数据。硬件知识，数据传输协议，数据处理技术。
  （设备，传输，数据处理）
#11.11
物联网包含软件和硬件，硬件随时间经常会有老化，腐蚀，污浊现象，灰可以清，锈难清。软件上的bug一定有，有时会直接导致电脑进入死循环，cpu被无限占用，
要能够实时监控计算机cpu，内存，硬盘数据。一款好的软件，不仅要用户体验，还要优化性能，尽量少占用cpu，内存，即在很差的电脑上也要运行流畅。衡量软件
优劣可以看看体验和cpu，内存在使用时的数据。掌握物联网就要掌握硬件和软件，让软件更小，性能更加，更加持久。物品老化是一个值得注意的问题。
  信息的查找要靠关键字和在一堆数据里面找出有用的数据。
    （遍历，预测，嵌入）
#11.12
数据以不同的形式展现，储存用二进制，转换成相应的数据要知道数据类型。
git包如果太久没更新有可能会失效，有一些功能源码已经放弃使用了，但是git有提供源码，只要在相应的文件上进行修改就可以使用。源码一般为其设计语言，
js，nodejs，c，pythod。。。
（改git包，改数据类型）
#11.13
位运算是涉及逻辑和数据的储存，是很基础的代码了，不同的二进制组合代表不同的意思。由二进制转换出来更新了更多的储存和传输形式，但都根据一定的格式。
ui界面或是其中的逻辑或许很简单，最可怕的是它进行了很多的扩展，而且不同设备传输的东西不同，如果没有对信息进行规范，单是学习相关文档，相关传输协议
就得花费很多时间。战士打靶看似简单，其实他们花在打靶的时间不多，大多都在进行体能训练，一切都是为了更好的射击。（规范，练习，衍生的练习）
不同类型占据不同的字节，根据不同类型进行不同的数据操作。
tcp以二进制传输，然后根据数据类型读取，一排的二进制数，按字节读取，不足一字节的用0来填充位。
##11.14
要知道代码的底层发生了什么就要对其中涉及的知识有一定了解，可以靠猜，然后去验证，或者去补充学习，要知道这一切绝对不会很难！
写代码要引用很多包，难度就在如何理解接口和避免包之间的冲突。
#11.16
看源码，要先了解整体的结构，在看懂每一句的作用。只有对全面的功能有所了解，才是去了解细节的时机。别人的代码过于庞大复杂，必须在脑海里自行补充其他信息，
在去别人的代码里验证。
源码基于它所基于的代码，在添加上许多的对象方法去把原始对象方法进行绚丽，好用的封装！
（原始方法上的对象包装）
#11.17
看别人的代码，首先是了解其结构，然后才能修改，最后才是优化
要全部结构都看懂才可以改的好，要都能改，才可以优化！
#11.18
声乐和光影的变换是UI的关键！
#11.19
redux中多个reducer合并，让每个reducer分别处理整个应用的一部分。
每个模块各自处理各自的模块，然后在需要的时候引进。
设计模式：通过面向对象，解决问题的方案。
不同设备间可能发生冲突，有时连报错都没有！清空重启是解决方法
js,es语法中基本有对所有类型数据的所有变形操作！
依靠数据间的关系来组织界面！理清数据间的关系是最重要的！
运用对象里面的方法只要参数是同种类型就可以使用！！
props的注入，然后还有数据DOM的引用！
数据类型不只有es中的几种，dom也是一种，相当于一种界面的表现形式。
一切都是模块，都可以往里面加东西，删东西，改东西。用看模块的眼光看一切代码，你就可以一直改，用别人的东西！
通过了解逻辑来更好的理解整个模块，一个个模块的组合变成了项目，有时候要根据要求变化界面，这时候就看自己对底层的逻辑是否清晰。从数据逻辑到页面，
可以是简单的数据类型，也可以是稍微复杂的类型，再到更加复杂的模块化。
#11.20
数据有不同的展示形式，只要掌握了它的形式就可以控制，转换。问题在数据的形式
数据的获取很重要，有时候要改数据需要引入其他对象的方法，这时候对象的继承机制就十分重要。有原型继承，工厂函数继承，构造继承。extends或者直接加！
#11.21
看视频了解一下全貌，靠实践去加深理解！看视频，实践中能对内容做多少的延展就看自己的专注度，思维。
代码的每个变化都需要函数来执行！（便于理解对象都结构）
找到问题到根源才是最重要到！
要掌握每个原始，了解对象的属性方法，了解dom后这个元素的样式，了解每个逻辑
（对象，dom样式，逻辑）
#11.22
学习：先通晓其大致结构，实践，最后读专业的介绍性书籍。
框架的某些特性更新了，要自己测试才能保持最新。自己探索框架，语法上的特性！
按dom进行多层分类相当于对逻辑进行多层分区！
模块的接耦合是逻辑类化的关键！
（模块化的关键在于对dom的从单个到群的不同js文件的模块化，还有通过相同操作归纳为一类的定义类接耦合法）
把每一块dom，和每一个功能用不同的js文件保存，便于维护和理解。
后端：树状的数据库，前端：树状的dom结构
#11.23
通过关键字寻找相应的信息，你可以通过这些方法，接口使用，其中较难的是有一些要求，而它无法实现要去试试找隐藏方法，还有一些要求可以实现，但是现在这个
接口不是完善，只有了解原理才能进行修改。
#11.24
要在开始一个项目前就大致把握整体结构，书写出来，然后按照顺序开始！
#11.26
选择大公司的框架，bug比较少，也好操作！
数据按照三层来进行分类，最底层为一个对象，对象里面不能在包含对象了。
要靠自己的逻辑来组合所有元素，把业务切分成小块，依靠自己的逻辑组合。
#11.27
三层数据逻辑关系，1.数据库的增删改查 2.页面间的逻辑联系 3.页面的逻辑处理
内部操作全靠猜，快得很
对东西对理解不同会影响个人决策和判断。所以要加深对事物对理解，越尝试越会有不同对体验，理解也会慢慢加深。
解耦和定时函数设为空是逻辑语言模块对关键
学得多，就可以多做点东西。
#11.28
数据变化就是信号传递建立关系
有些功能自己完成需要花费很多时间和精力，要相信在某个地方，有人已经完成了，所以多查资料就能帮你处理很多复杂的问题。通过网上
查找到的方法！
方法很清晰，最难的是找到按方法走出可行的路和理解其中的逻辑。
#11.29
npm包把相对复杂的源代码编写的功能聚合在一起，暴露几个简单的qpi供使用者使用。
要把控自己的代码主要是debug找出位置。type看出数据类型及数据是什么，是否正确！
最佳实践是时间和实践总结出来的，自己如果没有经验往往无法找到，要找到最佳实践需要有经验的人的知道和自己谦卑的实践，实行最佳实践的最大难度就是
自以为是，靠自己的理解去做，首先自己对问题的理解不足，其次自己对许多方法都不知道。放弃自己的思考，去遵守前辈的教导。
最佳实践！
需要引用时引用，需要创造时创造，节约资源，把共同的依赖放在一个总的文件，用一个变量控制多次使用的变量。
让一切都可以控制。
  在建立数据库时，把所有可能用到的数据类型进行预先定义。一个项目的架构在于数据库的建立，还有整个业务逻辑要清晰，如何让整个项目跑起来，手机端要考虑后台的
项目挂起。如何处理整个项目在运行时，数据要怎么处理。数据要时出错了，如何知道哪里出错（debug）。debug和数据持续运行时该如何处理逻辑。建立分区来统一管理
某个功能块，数据的解耦在于自身是否对于功能有足够的认识。然后最佳实践是知晓最佳作品的最佳思路。
  最佳实践就是对以往对成功案例进行分析，总结出要点和注意点。新人只需要按照说明来就可以做的很好。最佳实践相当于对事情对总结，精炼出最好的方法。
  最佳实践的模版！努力去理解每一个过程。自己的记忆力微不足道，所以还是靠网络来帮助你记忆吧。
#11.30
  最佳实践的重点在于是否能够理解每一个步骤，能否理解步骤的意图。所以重点在于理解。
  前端的页面分块，对某一操作对相关逻辑分块，后端数据库分块，后端数据操作逻辑分块。
  一个页面衍生出来对就放在这个文件夹下面，如果是一个新的页面就弄个新的文件夹。
  架构先把所有数据的类型罗列除开，然后在处理增删改查的数据库
  即使有很多限制，相应的也有很多解决方法！关键在于脑袋灵活度。通常情况下是自己限制了自己。运用框架必然有限制，看自己能不能找到突破限制的方法！
  清楚限制，和如何在限制下获得的材料运用起来，用以突破限制。
  数据库的创建取决于你要储存的物体信息。由此你便可以列出对象的key和value。
#12.1
  数据结构，组件化，数据处理，逻辑结构。数据的层级决定哪里开始调用方法，调用哪个对象的方法。层级，数据库，dom，逻辑
  页面的模块如果是高耦合就放一起，低耦合就切割开来。
  架构的重点在于把数据的结构用备注，说明出来。
  数据结构不要嵌套太深。按块分区。文档理解！
  理解一个知识，首先理解元素，然后了解如何创造出元素，最后理解它产生的原因
  快速学习：核心元素，如何使用，产生的原因。
  通过复制优秀的作品，能够最快速的达到目的。难点在于寻找和理解。
  最后实践。
  找到，总结，复制。（有些相应的补充要完成）
#12.3
  擅用浏览器可以快速的寻找到答案！浏览器加关键字。
  按着别人的知道前进。
  功能都有，只是形式不一样。
#12.4
  不同的包安装方式会对相同的代码产生影响。
  reactnative run android 会提示在安卓手机上跑时报的一些错误。
  电脑上的模拟器旁的照相机图标是用来开启照相机权限的。
  项目的设计先后顺序：数据类型和结构，dom的数据类型和结构，style的数据类型和结构，逻辑的处理。
  lodash处理深层次的操作。
  确认目标，然后理清思路，建立结构。
  lodash和updeep
  表单的格式是最佳实践！
  做页面最起码要把它完整的功能写出来，然后在去简化结构，复用数据。
  复用数据和dom，style，要把完整的功能做出来！
  一个组件的生命周期，包括开始，错误处理，成功处理。
  static是非实例化的类可以访问的，一旦实例化就不可以访问，但是实例化的对象都是拥有这个值的，在要实例化时，看看类有没有这个属性，有就加添一点东西，即
类在实例化时，会对类中的各种方法进行处理。static是在实例化是调用的。而props则是给使用着可以自行定义的东西。static只有开发者可以进行定义。props
使用者可以使用。
  封装即编译成一个包，对方引用，暴露了一些方法，类的实例化立面所有都东西都可以访问到
  类未实例化时都数据，实例化后都数据。
  类应该要传都参数。官方文档最简单都例子。npmjs里面都是官方说明。类和对象就是为了传递一些数据和方法都。
  全局变量，要么位置很前，要么用global关键字。
  暴露都要么是对象要么是方法。
  在去npm库里按照关键字找到最新都包。
  对于数据库都创建，dom有最佳实践到ui库里找，它提供了很多方法用来显示不同样式和状态都ui，然后是数据都处理，如果是相关一系列的操作，都可以找到。
所以最难的是理解它暴露的对象和api以及知道最新的技术。综上，跟上技术比较难。
  最佳实践的选择需要依赖经验和搜索。完整的结构。
#12.5
  git版本控制。拉取如果产生冲突，先把自己保存的放在一边，然后把自己的储存弹出，然后在有冲突的地方，采用拉取到的代码，然后在提交，就可以保存二者代码的
一致性，所以git协作一开始要先规定各自负责的部分，然后经常拉取和推送，通过交流来解决冲突文件。分配任务，然后交流解决冲突。
  组件export default一个类就可以，不要注入依赖，不然会一直循环嵌套，想取到组件里的内容就比较难。
#12.6
  curring是真正的计算逻辑，ramda 是js逻辑必掌握的。
  用不同方式运行代码可以获取不同的信息！
  通过重新定义输出函数，函数里面包含console命令，用函数来定义，即可以控制哪些要输出，哪些不输出！
  通过定义输出函数来更好的控制debug，修改错误！
  对象的查找和遍历是最好的。
  数据一旦躲起来，处理前端和后端就比较复杂。要考虑懒加载，并发。
  前端后端都要考虑当数据大起来大情况，前端要考虑ui的组件是否功能全面。
#12.7
  git要经常拉，保持提交时仍可以运行。
##12.8
  有很多模板，如果照着实践一遍，然后再做一次事情就简单多了，但是可能会有冲突，所以就要学会解决冲突，看看这一次与上一次的有什么不同，
网上可以找到很多资料，但是都不尽相同，还要探寻出每一个不同点里面的逻辑
  前端要根据组件切分，主要完成组件的逻辑。后端要判断每一个异步操作，并在回调时加上数据放回其状态，相当于可以报错了报对。
  #12.11
  todo高亮可以让你记住dev状态下做的一些事情，要在发布状态下进行相应的更改。所有的style都要统一放在一起好管理。
  所有的前端结构都要模块化，标准的结构便于管理：todo hightlight便于区分开发和发布状态要做的事情。
  代码逻辑的优化取决于是否可以进行数据的重复使用。
  promise函数返回一个reject和resolve来进行回调运用then可以执行接下去的函数。还有一个函数async，通过回调来执行告诉await异步执行完成。
async可以说你promise的升级，让回调函数更加清晰，结构可以更好理解。
  generator用来分段一个函数的执行，当一个回调执行到一个阶段，把函数的next嵌套下去，就可以执行了
  如果要做模块组件，不能有专有名称来做变量和props值
  如果不切分组件，完整逻辑的积累会让代码变得十分复杂，所以每一个组件都要做成组件，然后定义相应都props值。虽然很多ui都有很完整都组件
但是切分组件的主要原因，还是组件要处理的逻辑太多了！
#12.21
  只要返回一个next（），generator就会继续进行。
  数据库里的数据只是数据，真正的异步是在后台跑的进程。
  如果多个界面重复修改某个数据，最好把数据和修改动作放到中心仓库里。
  wihle（true）表示无限循环。通过异步调用可以执行next（）调用
  updeep在于修改原函数，ramda在于创造新函数
  把不同对象的数据结构都设为相似都，即他们都键作用相似的定义为一样的。
  还有他们相对的操作，如果都是添加，删除，修改，查找，所有传输都数据都要一样，便于管理。
  通用模块的数据state名称设为通用，这样才可以用在很多模块上
  用updeep来修改数据，返回一个新数据。ramda来筛选，比较，变化各种数据，重要执行数据的处理。这两个结合基本可以处理所有数据处理。多用ramda就可以掌握，
用ramda处理数据。
  saga里面提供了一些effect是回调函数，可以捕捉错误。yeild的要是promise，generator，saga里用call
  saga的run可以让generator一直跑下去。
#12.13
  saga可以暂停每一个yeild函数
  saga里面提供了一些effect是回调函数，可以捕捉错误。yeild的要是promise，saga里用callzhang z
  saga里面提供了一些effect是回调函数，可以捕捉错误。yeild的要是promise，generator，api，saga里用call便于debug堵塞，fork非堵塞
  saga只有等到take执行完才会执行下一步，所以take命令要并发执行，fork里finally可以监听取消
  一个页面的所有操作要想清楚了在去做，不然一旦数据结构确定后，要进行操作的增加就很难了。
  redux基本算是同步的，但是如果涉及到本地或者网络的存储和提取数据，那就算是异步逻辑了，需要一串异步的函数来统一管理一类异步操作。如果把数据存储在redxu
上了，那么提取操作就快多了，如果只是储存在redux上那速度也是很快的，基本不用异步函数来处理，也不用统一管理。
  看书，看资料能大概了解内容，只有亲自实践才能算是真正掌握。掌握东西需要时间，不要着急。有人指路可以少走很多弯路，可以更快地成长。
#12.14
  一个完整的组件和逻辑要经过测试，只有测试完成了，确认没有bug了，才可以交付使用。写完组件后要把如何使用的方法写清楚，需要传什么格式的文件，
以什么样的形式输出数据。即完成组件或者逻辑的编写后，要把输入和输出的数据格式和方法写完全，让人可以使用。
  在拿到别人写好的组件后，如果在使用上有发现什么问题，最好先问问写的人，这样可以最大程度的确定是否真的存在bug。
  写组件：完成某些功能，做好测试，写好注释
  用组件：根据说明进行操作，如果发现错误或者不理解的问问开发者，不要自己改代码。
#12.15
  小队合作，最好是把各自的代码分配清楚，各自负责各自的，有冲突交流解决。
  逻辑，同步最容易，异步靠回调解决，并发要靠队列处理！同步，异步，并发难度依次上升。
  已经完成了的组件，除非遇到大问题，否则最好不去更改。
  组件，数据类型，同步异步队列
  数据优化最好放在后期，因为要考虑算法什么的，渲染优化在前期就可以做了，渲染优化通过模块化可以部分实现。
  模块根据传入的数据是否有变化进行重新渲染，如果筛选数据可以让渲染条件变小，但是如果数据太大，进行筛选就比较费时。所以在数据进行筛选时，如果依赖的数据
太多，最好是比较一下有筛选和没筛选情况下那种体验比较好点。进行数据优化时要与渲染进行比较。进行渲染优化时有只渲染窗口显示的，在窗口显示中如果是按照模块
引入，又会根据传入组件的数据是否有变化来进行优化选择。render一次重新渲染都是重新渲染全部的，但是如果里面有组件，组件里的render又会再次进行一次是否重
新渲染的比较，相当于渲染在渲染。
  在进行储存时，io操作是非常耗时的，对于太频繁的增加操作要积攒到一定数目在进行储存，增删改查数据库里的文件是非常耗时的io在文件之间输入与输出是十分耗时
的，要进行优化，特别是频繁的io操作，优化策略就是积攒一定数量在io操作，这会导致一些数据未保存，如果是正常操作就要进行保存，可以控制的都要进行保存，catch
到error的状态也要进行保存操作。设置一个保存的指针和提取的指针来告知现在在数据库里有多少数据，现在提取了多少数据，在数据库中的位置，即有四个指针。
  （写用组件，同步异步队列数据操作，组件数据优化）
  找到bug是最重要的，尽量在settimeout里放纯函数
  debug的catch捕捉到到error位置写得很清楚了。
  不要在settimeout里引用其他需要引用到函数。函数引用传来传去很卡。
  模块引用直接与报错相关，只要有报错，一定可以找到根据模块到引用来找到出错点。
  方法的继承可以让一个class拥有更多的方法。npm包就是把方法写在class上，运用时，只需要传入正确的数据格式就可以用了。
  要看懂代码，会写代码，首先要看懂数据结构，然后是数据流向
  出现数据不连续就是并发时发生错误，要设置任务队列。
#12.17
  组件的位置如果没有父组件来做对照，很容易位置变得很奇怪，所以在设置组件的位置时要时刻考虑它的父组件是什么，父组件的宽高，位置。
  数据流动和组件相对位置关系
  数据结构的构建，取决于一个事件开始到结束需要有什么状态，还有它本身到属性，自定义属性，事件到开始到结束还有错误处理，与其他实物到某个属性到联系。
  数据结构最基础的就是class（static,constructor,props,methods),数据流向（promise,queue）
#12.18
  模拟事件比自己手动触发事件方便多了，而且还可以不按照项目多流出走，直接切入核心部分.
  把npm包里错误的文件修改，然后放到外面去，package也删除所依赖到包，以后每次调用后调用外面到文件。
  这个坑碰到多次就熟了，主要还是要用多个方法跑，找出错误的详细信息，多次尝试，多次推演。
  找准对方的逻辑
  逻辑的切分，每一部分完成相应的任务，没有多余的部分。对整体要有充分对了解，逻辑方面才好处理。很多方法都是要猜，然后在网上找验证
#12.19
  后台与异步操作不同，后台表示程序会一直跑，异步表示你可以手动结束
  一般都异步操作用async和await promise就可以了，要是遇到异步中还有异步，如io操作，要用saga，如有多个异步要用队列。
  有ramda和updeep对数据对处理就方便多了，渲染也可以排除多余多数据
  数据的格式要进行限制，接下去的扩展才有可能
#12.21
  每行代码都有它都作用，了解它都作用只是最基本的，更上一层是了解数据的流动，只有掌握了数据的流动才能真正掌握代码在整个系统里面发挥的作用。
#12.24
  数据没有全部同步更新会有bug
  理解业务逻辑和方法的逻辑很重要。一旦搞错，都要重来。思想不统一啊。
  开始的架构要清晰。
  一点的改变都会对整个逻辑的进程产生巨大的影响，会遍及到其他领域。
  数据的定义尽量不要采用常量，要统一更改就很麻烦，所以尽量在一个地方定义数据的动作
  弹窗的组件位置一般都在很顶层
#12.25
  页面通过class包起来，可以通过ref获得数据，style在ref中有变化，但是还是有用的
  数据state流动比action带动数据流动好用得多，应为不用考虑this的变化，state更好挂载
  组件的需要组合，有些组件效果不佳，需要测试是不是用错了，如果真的效果不佳要运用其他组件组合一下或者找其他组件，最好是不要自己写
  要理解整个业务的逻辑比较难，因为有很多的细节，而且在完成每一个环节有些部分很不满意，要进行多方的了解和测试。所以在整体理解业务的同时，还要在细部
多加揣摩。一开始不太可能能够全面了解，如果有经验，即时是模糊的概念，其实在记忆中也可以补充完整了，那就是在以前的基础上在进一步优化。做的次数越多，
如果还想优化，就会把项目做的更好。在以往的基础上，在进一步优化。一开始就要知道一些好的实践，然后照着样子在还原，总有办法可以实现的。
  如何把一个项目的每个环节做得完善，如何补充需要的功能，如何整理好整个项目，项目的分类。
  it就是数据的整理分类，流动。组件的组合形式。
  如何把庞大的信息整理清楚，让每一个数据都有地方可去，每一行代码都有意义
#12.26
  页面的每一个显示都是一种组件
  所有的页面变化都可以借由参数实现，前端的展示也是数据的结果
  有很多的页面和逻辑都是靠一步一步整理完善起来的
  做项目还是很依靠经验的，一开始就把项目的架构做完整了，以后要扩大就很容易。think big
#12.27
  数据更新只更新修改都部分，深复制成本很高。定时器尽量放在父组件上，减少定时器。shouldcomponentupdate来判断是否重新渲染，一旦定义就会覆盖程序
原先定义的。代码都扩展性要好
  如果显示会变化，根本不用修改数据库的值，只要加个函数，修改前端显示的值就可以
  如果不要修改大量数据，最好不要深复制函数
  定时器，组件不要重复，数据对象只修改对应的key
  如果某些功能无法实现，如果可以放在一边先放在一边
  关系型数据库用于处理数据间关系较多的，非关系型用于数据关系少的，非关系型的io操作比较快
  版本不一样，依赖的东西有变化，在引用npm包时就可能出错，因为模块引用来引用去
  nodejs模块在rn中也是要引用的
  报错已经把信息说得很清楚了
  在app.js处定义全局变量
  一个好的项目要考虑三点。一：每个功能的完整性即功能从开始到结束该有的行为，相应的速度即项目在数据和页面渲染处的优化，项目在可能出错的地方报错
#12.28
  每一行不同的代码都会发挥不同都作用，一般不会重合，一旦重合要去修改
  代码一旦完成最好不要去更改，除非是有bug。修改，增加代码尽量只在数据处修改
#12.29
  generator函数有yield就不会全部执行，saga有后台会把yield依次执行，哪里停住也可以
  尽量不要去创建新的对象，props除外
#12.30
  模块的好处，在我要在其他地方运用时，显现出来了，模块化的好处真的太多了，一起做过的直接拿来用，都不用重新在写一个了，而且十分浅显易懂，方便
  前端页面也是麻烦，要改得要死
  在网上可以找到各种功能的组件
  网上的组件都要试一试，有一些真的很难用
  有很多组件真的性能超差！！！！
  new date之间是可以比较的，hsl是color的另一种形式
#1.2
  注意数据的解耦，不然一旦有数据改变就会影响其他界面
  只要能清晰分辨数据和页面就可以很清楚的处理业务
  在了解了页面的结构后，把数据抽离出来就可以进行模块化了。
  如果依赖props，当redux的数据被删除时，很可能页面渲染就会出错。
  分块页面结构，抽离数据，区分依赖数据和需要更改的数据。
#1.3
  减少数据间的关联，采用非关系型数据库，关系型数据库逻辑间的关系使得整个项目的逻辑理解起来更加复杂，不利于优化
  前端的页面是需要不断推敲的，其中的自适应就需要考虑字体大小和宽高
  自适应采用弹性布局，左右放左右不要left，right拉开距离
  宽高，大小用相对值，位置用绝对值
  主题颜色要统一管理，然后所有需要改变色彩的地方都从一个地方来引入。字体大小，宽高要根据屏幕都分辨率来进行相应的变化，也就是说，所有的要自适应的地方都
应该引进这个总的函数，来根据屏幕的分辨率来变换字体以及宽高
  所有的页面全部都用组件的形式写，不用static
  只有px才能准确表示设备里面元素的大小，但是px不同设备又不同，所以要用dpi把px改成dp，在换成这个设备px的大小
  前端模块化，自适应，主题选择。后端异步编程，io操作。
  技术选型要比较多方的优缺点和自己的业务需要
  由业务来进行技术选型，技术的理解要结合业务的需求来理解。最难的还是业务的理解，即要完成什么样的产品
#1.4
  业务在一开始时不是十分清楚，是慢慢开始变得清楚，产品要细致地推敲，让每一个细节都符合预期，理想
  能组件化最好组件化，不然以后要改一点页面，很多设计到这个组件的页面都要改。
  代码规范，改代码就很方便，style统一管理
  自适应，主题，语言这是前端在设计之初，在逻辑方面就要提前准备的，把哪些内容用函数预先包裹起来
  前端组件化，然后对显示出来的每一个元素都设为可以变化的自定义。后端要注意数据存储的异步。
  数据流动和自适应
  定时器有时在函数内无法消除，最好在dom不挂载时清除
#1.5
  只有做到代码的复用才可能一个顶多个，而代码的复用需要留心页面的元素和代码的每一个。
  在测试时，如果哪里有错，compiler或则浏览器会报错。但是如果是发布版本就不会，所以要打印日志，把不同的信息打印出来，发布后会出错就在于页面是否按
预测的一样显示，更新数据。所以重点就在于把会变化的数据打印出来
  如果说万事万物都有一个策略，那么是否该在一开始的时候把框架弄好。之前有过类似的经验，效果不错，就是需要事先准备，我不喜好预备，现在想来是比较不妥。
#1.7
  如果能搞清楚每个数据的作用就很容易修改代码
  数据经过多次传递，即时是模块化了修改起来也是十分麻烦，所以进行把所有依赖的模块放在一起，不要进行多数据的切割
  数据模块化必然会导致数据的多次传递。
  减少层级就要注意页面的布局，不要让一个组件嵌套多个组件，组件的嵌套是很容易出错的
  多个逻辑公用一个页面要有一个数据来区分数据。所以重点在于对于数据之间的联系和区分是否有清晰认识，可以根据数据的结构来进行数据的解析。
  数据结构和数据流动
  不仅页面要修改，功能也要测试！测试要注意哪些是之前跑得通得，哪些是新加的，新加的很有可能会导致之前的操作产生错误
  按键要避免多次点击
  try catch用来处理语法报错信息
  没有把最基本的逻辑，数据流动搞清楚，整个代码对我而言就是一团浆糊。
  整个数据的逻辑从开始到结束，而且要确认是否每一部分是否发挥作用。
  改代码，就是要知道先后顺序的逻辑还有确保每一部分发挥作用
  读懂需要理解和推理，确保发挥作用要知道这个npm包怎么用。按照顺序来推，不要太着急，前面的推导完，后面的应该也不是问题，打好基础，做好准备。
  先整体大概的看逻辑，自己推出可能性，在从文档看它决定的方向，然后按照预先想好的可能性套进去。
  自己能在多短的时间能把握整体的逻辑，然后按照提示去修饰。
  我只需要想出一条逻辑，然后去修正就可以了，如果时间充足还可以去试想多种可能，然后作为预备的方案
  并不是这个项目要做很久，而是你没掌握方法，不是你没掌握方法，而是你没有抓到问题的关键，只有把有问题的范围缩小到一定范围才可以迅速地理解，处理
  编程是实践学科，所以要看别人怎么写代码的，你才能知道怎么写代码
  做事前一定要有策略，然后按照策略走。很多事情都是有相似性的，所以举一反三可以帮助你了解，计划更多东西
  一切的策略都是推论，要有素材
#1.8
  写代码用其他人的npm包如果没有遵守他的规则就服务正确地运行
  最好是顺着npm组件包的逻辑，如果硬是要修改成自己想要的，一定会产生一些问题，当然这是没有办法避免的，除非你重新写一个
  不是不能改，该起来挺麻烦的要注意是否界面的其他组件和自己写的是否一致
  逻辑结构可以完全选取最佳实践，然而在做前端页面时，有很多组件不是很理想，这时只能自己写一个全局的组件。自己不重写组件，一旦重写一定要全局写，这样
才能和页面的其他组件匹配。如果组件写起来太麻烦了，最好是多去网上找找看有没有符合要求的组件。
  按照他人逻辑写，和自己写全局。
  改bug最难的是确认问题在那。
  页面理解容易，写起来也容易。逻辑理解难，写起来容易。
  写得函数和组件最好都在全局使用，这样整个代码该起来容易，页面也统一。组件有通用组件，逻辑有类归纳。
#1.9
  要对逻辑或则是组件进行监控就要全局定义和通用组件
  写代码重要的是对每一行进行监控
  看不懂的部分才是代码的关键
  细节是写代码的关键
  单个数据无法体现出对细节的理解，只有数量达到一定时，才需要处理细节的东西。
  数据库的设计需要策略，如何处理大数据也是需要策略的。
  很多操作和逻辑十分简单，这是当数据变多时，队列，超时，优先级等一系列问题就出来了。
  功能的增加是在原先的基础上，多增加出一条线来处理新增的逻辑。也就是说在原来的基础上，原先的结构的基础上做的延伸。只要原先有基础在构建就比较容易。
麻烦的是从头开始写，从头写的话最好参考别人的策略来建立数据库。数量多的时候逻辑要理清楚。页面组件大小要统一，尽量采用单一的组件，如果有不同类别的
部分也要确保各类组件间是否协调。
