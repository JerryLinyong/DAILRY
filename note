#11.02
es6的语法对变量的赋值，数据类型的操作增加，让最基本的单位数据类型的操作增加了，把数据分割成一个个基本类型，然后对基本类型数据开始操作，基本数据类型按照
层级分类，聚集成一个个数据集合，如数组，对象，set，map。基本数据类型数字，字符串，布尔，symbol类型的数据。集合放在对象中。对象不仅可以储存数据，还可以
储存方法。方法中有自身的方法，还有继承来的方法使用class来定义对象，extends来继承，还有proxy来拦截原型的方法，reflect用来定义，重写原型的方法。/
还有模块的引用，require是实时的，import是提前的，更加快速，但是其中的数值不能发生变化。还有就是异步操作。promise完成单个异步函数的操作，回调，
而yeild async则是将方法内部的步骤在进行细分。
dom树的建立，css样式表的建立，数值的引用，绑定和方法的挂载
#11.03
数据结构，算法的基本认识。传输数据需要事先规定好数据传输的形式，如何传输，于是有了很多的协议方式。
根据不同的协议，还有不同的框架，衍生出了许多不同的代码库，这些git上的开源代码打包了很多有用的接口，通过下载包，引用，通过api进行相应的操作，唯一比较
麻烦的是由于数据框架，技术一直在发展，所以很多包都要相应的更新，人的需求也在不断改变，代码更新程度将影响到这个技术的使用范围。所以了解人变化的需求和
掌握最新的技术成为当务之急。想要了解人的需求还是要多问人，多去考察。而新技术也是要多问人，多在网上找资料。还有就是如何能够真正的掌握技术。掌握技术在于
掌握其原理，只有把技术的底部实现原理掌握了才算真的掌握，而一项技术通常可以解决多个问题，所以学的深浅也看你的需求有多少！
#11.04
尽量把自己每日所要做的事情变少，然后把每一件事情做好，知识，设备，活动。
#11.05
不怎么需要的东西就不要出现在生活里，会分心，需要的东西也要注意限制，没有限制就不能各自发挥所长！
#11.06
对象的方法的继承和修饰词来为对象添加个别的方法，继承extends添加多个方法，constructor添加独一属性用来区别，
异步通过记号来告诉函数，此次异步执行完毕，可以执行下一个，resolve和reject
（RYZ）
#11.07
  最佳实践：掌握相关技术，根据要求把技术进行合理运用，追求代码量少简单易懂，运行快。
  设计模式：实现项目所需要的技术，并列出在哪要用上这项技术,如store：redux,react-redux,async-storage,MQTT,redux-saga。这是实现store项目所要的技术
  完成项目需要对相关技术的一定了解，由此来进行技术选型，完成设计模式，然后由对技术的深刻理解来完成最佳实践！
  代码的管理：先把框架搭起来，用最简单的代码把整个项目的的依赖库安装，引入在入口文件里，然后创建相应的文件夹，往里面放入相应的代码。以后对项目的更改都
是在相应的文件里面修改，一般情况下尽量不要增减文件数量，会有许多东西要改，所以一开始的项目结构搭建很重要，要确定
  1.需要哪些页面 login main
  2.用什么框架 vue react
  3.ui库，ant design
  4.信息用什么引入，ajax，axios，mqtt
  5.路由怎么搭建
  6.中心仓库是什么
其中路由和技术的选择是要在一开始就做得详细的!
(最佳实践！参考别人的工程文件，文件的结构‘如何模块化’，应用的技术‘选择相应的部分’)\
！开始的页面搭建，然后技术选择，页面：框架和ui，数据处理比较麻烦：语言转换，运用不同的协议获取不同的数据，把数据储存在不同的地方，引用数据，修改数据，
嵌套数据，异步执行，数据类型，依据不同的操作系统有不同的表现引用不同的技术。
 数据储存，引用会影响系统的优化。主要在数据是否可以复用！import和储存和网络请求
（页面样式，响应不同的操作）
（获取数据，数据储存，数据处理）
#11.08
各个组件可能有所依赖，最好是看文档，依据文档来进行使用。组件需要整理，让整个文档结构更加清晰。
对整个项目的需求要很清楚才能把项目很好的切分。
一开始要先有个整体概念，然后根据需求不断往上面添加依赖库和界面。
项目由'页面'和'数据'组成，'组织'它们使其简单易懂。
#11.09
每个电子设备通过不同的协议进行通信。软件硬件，有服务器去处理请求，处理信息。单片机，二极管，芯片等等。wifi透传，tcp/ip，websocket，tcp，mqtt，
http不同的数据连接需要不同的包来处理。对数据的转码也需要包，对转码后的数据也需要包来处理。硬件来提供数据计算，储存，接收，发送，软件来处理数据，
接收。设备处理数据，发送数据，接收数据。硬件知识，数据传输协议，数据处理技术。
  （设备，传输，数据处理）
#11.11
物联网包含软件和硬件，硬件随时间经常会有老化，腐蚀，污浊现象，灰可以清，锈难清。软件上的bug一定有，有时会直接导致电脑进入死循环，cpu被无限占用，
要能够实时监控计算机cpu，内存，硬盘数据。一款好的软件，不仅要用户体验，还要优化性能，尽量少占用cpu，内存，即在很差的电脑上也要运行流畅。衡量软件
优劣可以看看体验和cpu，内存在使用时的数据。掌握物联网就要掌握硬件和软件，让软件更小，性能更加，更加持久。物品老化是一个值得注意的问题。
  信息的查找要靠关键字和在一堆数据里面找出有用的数据。
    （遍历，预测，嵌入）
#11.12
数据以不同的形式展现，储存用二进制，转换成相应的数据要知道数据类型。
git包如果太久没更新有可能会失效，有一些功能源码已经放弃使用了，但是git有提供源码，只要在相应的文件上进行修改就可以使用。源码一般为其设计语言，
js，nodejs，c，pythod。。。
（改git包，改数据类型）
#11.13
位运算是涉及逻辑和数据的储存，是很基础的代码了，不同的二进制组合代表不同的意思。由二进制转换出来更新了更多的储存和传输形式，但都根据一定的格式。
ui界面或是其中的逻辑或许很简单，最可怕的是它进行了很多的扩展，而且不同设备传输的东西不同，如果没有对信息进行规范，单是学习相关文档，相关传输协议
就得花费很多时间。战士打靶看似简单，其实他们花在打靶的时间不多，大多都在进行体能训练，一切都是为了更好的射击。（规范，练习，衍生的练习）
不同类型占据不同的字节，根据不同类型进行不同的数据操作。
tcp以二进制传输，然后根据数据类型读取，一排的二进制数，按字节读取，不足一字节的用0来填充位。
##11.14
要知道代码的底层发生了什么就要对其中涉及的知识有一定了解，可以靠猜，然后去验证，或者去补充学习，要知道这一切绝对不会很难！
写代码要引用很多包，难度就在如何理解接口和避免包之间的冲突。
#11.16
看源码，要先了解整体的结构，在看懂每一句的作用。只有对全面的功能有所了解，才是去了解细节的时机。别人的代码过于庞大复杂，必须在脑海里自行补充其他信息，
在去别人的代码里验证。
源码基于它所基于的代码，在添加上许多的对象方法去把原始对象方法进行绚丽，好用的封装！
（原始方法上的对象包装）
#11.17
看别人的代码，首先是了解其结构，然后才能修改，最后才是优化
要全部结构都看懂才可以改的好，要都能改，才可以优化！
#11.18
声乐和光影的变换是UI的关键！
#11.19
redux中多个reducer合并，让每个reducer分别处理整个应用的一部分。
每个模块各自处理各自的模块，然后在需要的时候引进。
设计模式：通过面向对象，解决问题的方案。
不同设备间可能发生冲突，有时连报错都没有！清空重启是解决方法
js,es语法中基本有对所有类型数据的所有变形操作！
依靠数据间的关系来组织界面！理清数据间的关系是最重要的！
运用对象里面的方法只要参数是同种类型就可以使用！！
props的注入，然后还有数据DOM的引用！
数据类型不只有es中的几种，dom也是一种，相当于一种界面的表现形式。
一切都是模块，都可以往里面加东西，删东西，改东西。用看模块的眼光看一切代码，你就可以一直改，用别人的东西！
通过了解逻辑来更好的理解整个模块，一个个模块的组合变成了项目，有时候要根据要求变化界面，这时候就看自己对底层的逻辑是否清晰。从数据逻辑到页面，
可以是简单的数据类型，也可以是稍微复杂的类型，再到更加复杂的模块化。
#11.20
数据有不同的展示形式，只要掌握了它的形式就可以控制，转换。问题在数据的形式
数据的获取很重要，有时候要改数据需要引入其他对象的方法，这时候对象的继承机制就十分重要。有原型继承，工厂函数继承，构造继承。extends或者直接加！
#11.21
看视频了解一下全貌，靠实践去加深理解！看视频，实践中能对内容做多少的延展就看自己的专注度，思维。
代码的每个变化都需要函数来执行！（便于理解对象都结构）
找到问题到根源才是最重要到！
要掌握每个原始，了解对象的属性方法，了解dom后这个元素的样式，了解每个逻辑
（对象，dom样式，逻辑）
#11.22
学习：先通晓其大致结构，实践，最后读专业的介绍性书籍。
框架的某些特性更新了，要自己测试才能保持最新。自己探索框架，语法上的特性！
按dom进行多层分类相当于对逻辑进行多层分区！
模块的接耦合是逻辑类化的关键！
（模块化的关键在于对dom的从单个到群的不同js文件的模块化，还有通过相同操作归纳为一类的定义类接耦合法）
把每一块dom，和每一个功能用不同的js文件保存，便于维护和理解。
后端：树状的数据库，前端：树状的dom结构
#11.23
通过关键字寻找相应的信息，你可以通过这些方法，接口使用，其中较难的是有一些要求，而它无法实现要去试试找隐藏方法，还有一些要求可以实现，但是现在这个
接口不是完善，只有了解原理才能进行修改。
#11.24
要在开始一个项目前就大致把握整体结构，书写出来，然后按照顺序开始！
#11.26
选择大公司的框架，bug比较少，也好操作！
数据按照三层来进行分类，最底层为一个对象，对象里面不能在包含对象了。
要靠自己的逻辑来组合所有元素，把业务切分成小块，依靠自己的逻辑组合。
#11.27
三层数据逻辑关系，1.数据库的增删改查 2.页面间的逻辑联系 3.页面的逻辑处理
内部操作全靠猜，快得很
对东西对理解不同会影响个人决策和判断。所以要加深对事物对理解，越尝试越会有不同对体验，理解也会慢慢加深。
解耦和定时函数设为空是逻辑语言模块对关键
学得多，就可以多做点东西。
#11.28
数据变化就是信号传递建立关系
有些功能自己完成需要花费很多时间和精力，要相信在某个地方，有人已经完成了，所以多查资料就能帮你处理很多复杂的问题。通过网上
查找到的方法！
方法很清晰，最难的是找到按方法走出可行的路和理解其中的逻辑。
#11.29
npm包把相对复杂的源代码编写的功能聚合在一起，暴露几个简单的qpi供使用者使用。
要把控自己的代码主要是debug找出位置。type看出数据类型及数据是什么，是否正确！
最佳实践是时间和实践总结出来的，自己如果没有经验往往无法找到，要找到最佳实践需要有经验的人的知道和自己谦卑的实践，实行最佳实践的最大难度就是
自以为是，靠自己的理解去做，首先自己对问题的理解不足，其次自己对许多方法都不知道。放弃自己的思考，去遵守前辈的教导。
最佳实践！
需要引用时引用，需要创造时创造，节约资源，把共同的依赖放在一个总的文件，用一个变量控制多次使用的变量。
让一切都可以控制。
  在建立数据库时，把所有可能用到的数据类型进行预先定义。一个项目的架构在于数据库的建立，还有整个业务逻辑要清晰，如何让整个项目跑起来，手机端要考虑后台的
项目挂起。如何处理整个项目在运行时，数据要怎么处理。数据要时出错了，如何知道哪里出错（debug）。debug和数据持续运行时该如何处理逻辑。建立分区来统一管理
某个功能块，数据的解耦在于自身是否对于功能有足够的认识。然后最佳实践是知晓最佳作品的最佳思路。
  最佳实践就是对以往对成功案例进行分析，总结出要点和注意点。新人只需要按照说明来就可以做的很好。最佳实践相当于对事情对总结，精炼出最好的方法。
  最佳实践的模版！努力去理解每一个过程。自己的记忆力微不足道，所以还是靠网络来帮助你记忆吧。
#11.30
  最佳实践的重点在于是否能够理解每一个步骤，能否理解步骤的意图。所以重点在于理解。
  前端的页面分块，对某一操作对相关逻辑分块，后端数据库分块，后端数据操作逻辑分块。
  一个页面衍生出来对就放在这个文件夹下面，如果是一个新的页面就弄个新的文件夹。
  架构先把所有数据的类型罗列除开，然后在处理增删改查的数据库
  即使有很多限制，相应的也有很多解决方法！关键在于脑袋灵活度。通常情况下是自己限制了自己。运用框架必然有限制，看自己能不能找到突破限制的方法！
  清楚限制，和如何在限制下获得的材料运用起来，用以突破限制。
  数据库的创建取决于你要储存的物体信息。由此你便可以列出对象的key和value。
#12.1
  数据结构，组件化，数据处理，逻辑结构。数据的层级决定哪里开始调用方法，调用哪个对象的方法。层级，数据库，dom，逻辑
  页面的模块如果是高耦合就放一起，低耦合就切割开来。
  架构的重点在于把数据的结构用备注，说明出来。
  数据结构不要嵌套太深。按块分区。文档理解！
  理解一个知识，首先理解元素，然后了解如何创造出元素，最后理解它产生的原因
  快速学习：核心元素，如何使用，产生的原因。
  通过复制优秀的作品，能够最快速的达到目的。难点在于寻找和理解。
  最后实践。
  找到，总结，复制。（有些相应的补充要完成）
#12.3
  擅用浏览器可以快速的寻找到答案！浏览器加关键字。
  按着别人的知道前进。
  功能都有，只是形式不一样。
#12.4
  不同的包安装方式会对相同的代码产生影响。
  reactnative run android 会提示在安卓手机上跑时报的一些错误。
  电脑上的模拟器旁的照相机图标是用来开启照相机权限的。
  项目的设计先后顺序：数据类型和结构，dom的数据类型和结构，style的数据类型和结构，逻辑的处理。
  lodash处理深层次的操作。
  确认目标，然后理清思路，建立结构。
  lodash和updeep
  表单的格式是最佳实践！
  做页面最起码要把它完整的功能写出来，然后在去简化结构，复用数据。
  复用数据和dom，style，要把完整的功能做出来！
  一个组件的生命周期，包括开始，错误处理，成功处理。
  static是非实例化的类可以访问的，一旦实例化就不可以访问，但是实例化的对象都是拥有这个值的，在要实例化时，看看类有没有这个属性，有就加添一点东西，即
类在实例化时，会对类中的各种方法进行处理。static是在实例化是调用的。而props则是给使用着可以自行定义的东西。static只有开发者可以进行定义。props
使用者可以使用。
  封装即编译成一个包，对方引用，暴露了一些方法，类的实例化立面所有都东西都可以访问到
  类未实例化时都数据，实例化后都数据。
  类应该要传都参数。官方文档最简单都例子。npmjs里面都是官方说明。类和对象就是为了传递一些数据和方法都。
  全局变量，要么位置很前，要么用global关键字。
  暴露都要么是对象要么是方法。
  在去npm库里按照关键字找到最新都包。
  对于数据库都创建，dom有最佳实践到ui库里找，它提供了很多方法用来显示不同样式和状态都ui，然后是数据都处理，如果是相关一系列的操作，都可以找到。
所以最难的是理解它暴露的对象和api以及知道最新的技术。综上，跟上技术比较难。
  最佳实践的选择需要依赖经验和搜索。完整的结构。
#12.5
  git版本控制。拉取如果产生冲突，先把自己保存的放在一边，然后把自己的储存弹出，然后在有冲突的地方，采用拉取到的代码，然后在提交，就可以保存二者代码的
一致性，所以git协作一开始要先规定各自负责的部分，然后经常拉取和推送，通过交流来解决冲突文件。分配任务，然后交流解决冲突。
  组件export default一个类就可以，不要注入依赖，不然会一直循环嵌套，想取到组件里的内容就比较难。
#12.6
  curring是真正的计算逻辑，ramda 是js逻辑必掌握的。
  用不同方式运行代码可以获取不同的信息！
  通过重新定义输出函数，函数里面包含console命令，用函数来定义，即可以控制哪些要输出，哪些不输出！
  通过定义输出函数来更好的控制debug，修改错误！
  对象的查找和遍历是最好的。
  数据一旦躲起来，处理前端和后端就比较复杂。要考虑懒加载，并发。
  前端后端都要考虑当数据大起来大情况，前端要考虑ui的组件是否功能全面。
#12.7
  git要经常拉，保持提交时仍可以运行。
##12.8
  有很多模板，如果照着实践一遍，然后再做一次事情就简单多了，但是可能会有冲突，所以就要学会解决冲突，看看这一次与上一次的有什么不同，
网上可以找到很多资料，但是都不尽相同，还要探寻出每一个不同点里面的逻辑
  前端要根据组件切分，主要完成组件的逻辑。后端要判断每一个异步操作，并在回调时加上数据放回其状态，相当于可以报错了报对。
  #12.11
  todo高亮可以让你记住dev状态下做的一些事情，要在发布状态下进行相应的更改。所有的style都要统一放在一起好管理。
  所有的前端结构都要模块化，标准的结构便于管理：todo hightlight便于区分开发和发布状态要做的事情。
  代码逻辑的优化取决于是否可以进行数据的重复使用。
  promise函数返回一个reject和resolve来进行回调运用then可以执行接下去的函数。还有一个函数async，通过回调来执行告诉await异步执行完成。
async可以说你promise的升级，让回调函数更加清晰，结构可以更好理解。
  generator用来分段一个函数的执行，当一个回调执行到一个阶段，把函数的next嵌套下去，就可以执行了
  如果要做模块组件，不能有专有名称来做变量和props值
  如果不切分组件，完整逻辑的积累会让代码变得十分复杂，所以每一个组件都要做成组件，然后定义相应都props值。虽然很多ui都有很完整都组件
但是切分组件的主要原因，还是组件要处理的逻辑太多了！
#12.21
  只要返回一个next（），generator就会继续进行。
  数据库里的数据只是数据，真正的异步是在后台跑的进程。
  如果多个界面重复修改某个数据，最好把数据和修改动作放到中心仓库里。
  wihle（true）表示无限循环。通过异步调用可以执行next（）调用
  updeep在于修改原函数，ramda在于创造新函数
  把不同对象的数据结构都设为相似都，即他们都键作用相似的定义为一样的。
  还有他们相对的操作，如果都是添加，删除，修改，查找，所有传输都数据都要一样，便于管理。
  通用模块的数据state名称设为通用，这样才可以用在很多模块上
  用updeep来修改数据，返回一个新数据。ramda来筛选，比较，变化各种数据，重要执行数据的处理。这两个结合基本可以处理所有数据处理。多用ramda就可以掌握，
用ramda处理数据。
  saga里面提供了一些effect是回调函数，可以捕捉错误。yeild的要是promise，generator，saga里用call
  saga的run可以让generator一直跑下去。
#12.13
  saga可以暂停每一个yeild函数
  saga里面提供了一些effect是回调函数，可以捕捉错误。yeild的要是promise，saga里用callzhang z
  saga里面提供了一些effect是回调函数，可以捕捉错误。yeild的要是promise，generator，api，saga里用call便于debug堵塞，fork非堵塞
  saga只有等到take执行完才会执行下一步，所以take命令要并发执行，fork里finally可以监听取消
  一个页面的所有操作要想清楚了在去做，不然一旦数据结构确定后，要进行操作的增加就很难了。
  redux基本算是同步的，但是如果涉及到本地或者网络的存储和提取数据，那就算是异步逻辑了，需要一串异步的函数来统一管理一类异步操作。如果把数据存储在redxu
上了，那么提取操作就快多了，如果只是储存在redux上那速度也是很快的，基本不用异步函数来处理，也不用统一管理。
  看书，看资料能大概了解内容，只有亲自实践才能算是真正掌握。掌握东西需要时间，不要着急。有人指路可以少走很多弯路，可以更快地成长。
  saga只有等到take执行完才会执行下一步，所以take命令要并发执行，fork里finally可以监听取消xia
  saga只有等到take执行完才会执行下一步，所以take命令要并发执行，fork里finally可以监听取消xia
  saga只有等到take执行完才会执行下一步，所以take命令要并发执行，fork里finally可以监听取消
后端：树状的数据库，前端：树状的dom结构b
后端：树状的数据库，前端：树状的dom结构
